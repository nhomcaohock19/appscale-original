# Programmer: Chris Bunch


import os
import random
import sys


from django.utils import simplejson as json
from google.appengine.api import users
from google.appengine.api.appscale import neptune


# The maximum value that can be used when generating random filenames for
# Neptune job files.
MAX_RAND_FILE_VAL = 1000000


# The full path to the Neptune executable on this virtual machine.
NEPTUNE_PATH = "/usr/lib/ruby/gems/1.8/gems/neptune-0.2.2/bin/neptune"


class BabelException(Exception):
  """
    BabelException is a custom exception type that is thrown whenever method
      calls in the Babel API are called incorrectly or experience unexpected
      behaviors.
  """
  pass


"""
  Babel API: Enables users to submit Babel jobs, a simplified version of running
    Neptune jobs, making it easier to poll for the standard output/error
    produced by running arbitrary code.
"""


def can_run_jobs():
  """
    Determines if jobs can be run from this machine, and is primarily used by
    the AppLoadBalancer's status page. Since babel is installed everywhere and 
    is called locally, it's available from everywhere.
  """
  return True


def run_job(params):
  """
    Runs a babel job with the given parameters.

    Arguments:
      params: A dict that will be used as the parameters to this babel job.

    Raises:
      BabelException: If called with params in a non-dict format, or if any
        param given in the params dict is not a string or list.
      NeptuneException: If the currently logged in user is not authorized to
        run Babel jobs (which reduce to Neptune jobs).

    Returns:
      A dict that indicates if the babel job was started successfully. If the
        job was started successfully, it also includes keys that indicate the
        standard output, error, and metadata for this job. If the job was not
        started started successfully, the reason why the job failed to start is
        also included.
  """
  neptune.ensure_user_is_neptune_authorized()
  if not isinstance(params, dict):
    raise BabelException("params not a dict")

  contents = "require 'rubygems'\n"
  contents += "require 'babel'\n"
  contents += "require 'json'\n\n"
  contents += "task = babel({\n"

  for k, v in params.iteritems():
    if isinstance(v, str):
      contents += "  %s => '%s',\n" % (k, v)
    elif isinstance(v, list):
      contents += "  %s => [" % k
      for item in v:
        contents += "'%s', " % str(item)
      contents += "],\n"
    else:
      raise BabelException("v was not a str or list")
  
  contents += "  :run_local => true,\n"
  contents += "  :engine => 'executor-rabbitmq',\n"
  contents += "  :is_remote => false})\n\n"
  contents += "puts task.to_json()\n"

  file_location = "/tmp/babel-job-%s.rb" % str(random.randint(0,
    MAX_RAND_FILE_VAL))
  f = open(file_location, "w+")
  f.write(contents)
  f.close()

  sys.stderr.write("write file at %s" % file_location)
  encoded_result = os.popen("%s %s" % (NEPTUNE_PATH, file_location)).read()
  sys.stderr.write("job result was [%s]" % encoded_result)
  return json.loads(encoded_result)


def get_output(params):
  """
    Gets the standard output produced by the given babel job.

    Arguments:
      params: A string that represents a JSON-encoded dict, which must contain a
        key named 'output' that points to the output location of the given babel
        job.

    Raises:
      NeptuneException: If the currently logged in user is not authorized to
        run Babel jobs (which reduce to Neptune jobs).

    Returns:
      A string whose contents are the standard output generated by the babel job
        identified by params['output'].
  """
  neptune.ensure_user_is_neptune_authorized()
  contents = "require 'rubygems'\n"
  contents += "require 'json'\n"
  contents += "require 'neptune'\n\n"
  contents += "encoded_result = '%s'\n\n" % params
  contents += "task = TaskInfo.new(encoded_result)\n"
  contents += "puts task.stdout\n"

  file_location = "/tmp/babel-job-%s.rb" % str(random.randint(0,
    MAX_RAND_FILE_VAL))
  f = open(file_location, "w+")
  f.write(contents)
  f.close()

  sys.stderr.write("write file at %s" % file_location)
  output = os.popen("%s %s" % (NEPTUNE_PATH, file_location)).read()
  sys.stderr.write("job result was [%s]" % output)
  return output
